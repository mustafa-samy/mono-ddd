import { ComponentFixture, TestBed } from '@angular/core/testing';
import { of, Observable } from 'rxjs';
import { <%= classify(name) %>PageComponent } from './<%= dasherize(name) %>-page.component';
import { GetAll<%= classify(name) %>UseCase } from '<%= modifiedPath %>/data/use-cases/get-all-<%= dasherize(name) %>.usecase';
import { <%= classify(name) %> } from '<%= modifiedPath %>/data/model/<%= dasherize(name) %>.model';
import { ChangeDetectionStrategy } from '@angular/core';

// Mock the use case
class MockGetAll<%= classify(name) %>UseCase {
  execute(): Observable<<%= classify(name) %>[]> {
    return of([]); // Default to empty array
  }
}

describe('<%= classify(name) %>PageComponent', () => {
  let component: <%= classify(name) %>PageComponent;
  let fixture: ComponentFixture<<%= classify(name) %>PageComponent>;
  let useCase: GetAll<%= classify(name) %>UseCase;

  const mockData: <%= classify(name) %>[] = [
    { id: '1', name: 'First Item' },
    { id: '2', name: 'Second Item' },
  ];

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      declarations: [ <%= classify(name) %>PageComponent ],
      providers: [
        { provide: GetAll<%= classify(name) %>UseCase, useClass: MockGetAll<%= classify(name) %>UseCase }
      ]
    })
    // Override component metadata to simplify testing
    .overrideComponent(<%= classify(name) %>PageComponent, {
        set: { changeDetection: ChangeDetectionStrategy.Default }
    })
    .compileComponents();
  });

  beforeEach(() => {
    fixture = TestBed.createComponent(<%= classify(name) %>PageComponent);
    component = fixture.componentInstance;
    useCase = TestBed.inject(GetAll<%= classify(name) %>UseCase);
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });

  it('should call the use case on init', () => {
    const useCaseSpy = spyOn(useCase, 'execute').and.returnValue(of(mockData));
    component.ngOnInit();
    expect(useCaseSpy).toHaveBeenCalled();
  });

  it('should display a loading message before data arrives', () => {
    // Don't call ngOnInit or detectChanges yet
    const compiled = fixture.nativeElement;
    expect(compiled.querySelector('p')?.textContent).toContain('Loading items...');
  });

  it('should render a list of items when data is available', () => {
    spyOn(useCase, 'execute').and.returnValue(of(mockData));
    fixture.detectChanges(); // Triggers ngOnInit and data binding

    const compiled = fixture.nativeElement;
    const listItems = compiled.querySelectorAll('.item');

    expect(listItems.length).toBe(2);
    expect(listItems[0].textContent).toContain('First Item');
    expect(listItems[1].textContent).toContain('Second Item');
    expect(compiled.querySelector('p')).toBeNull(); // No loading or no-items message
  });

  it('should display a "no items" message if the data array is empty', () => {
    spyOn(useCase, 'execute').and.returnValue(of([]));
    fixture.detectChanges(); // Triggers ngOnInit and data binding

    const compiled = fixture.nativeElement;
    const listItems = compiled.querySelectorAll('.item');

    expect(listItems.length).toBe(0);
    expect(compiled.querySelector('p')?.textContent).toContain('No items found.');
  });
});
